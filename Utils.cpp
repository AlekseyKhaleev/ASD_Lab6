#include "Utils.h"

int NextRand(int start_key) {
    /****************************************************************************************************************
   * Цель: Возврат следующего случайного числа
   * Исходные данные:
   *      start_key   - начальный ключ ЛКГ генератора
   *      rand_num    - следующее случайное число, вычисляемое по принципу ЛКГ
   * Результат: функция возвращает случайное число
   * Вызываемые модули: -
   * Описание алгоритма:
   * 1) Передаваемый в функцию аргумент имеет значение по умолчанию, равное 0. Таким образом функция не требует
   * явного указания стартового ключа, однако его стоит задать, для упрощения задачи дешифрования, а также получения
   * последовательности при вызове без аргументов.
   * 2) Переменная rand_num является статической - ее значение не теряется при выходе из области видимости функции,
   * это необходимо для получения псевдо-случайной последовательности.
   * 3) При каждом вызове производится расчет следующего члена ПСП по формуле Д.Г. Лемера. Константы удовлетворяют
   * условиям получения "хорошей" последовательности, для данной функции период равен 7875.
   * Дата: 27 / 11 / 2022 Версия 1.01
   * Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
   * Исправления: нет
   ****************************************************************************************************************/
    static int rand_num{0};
    if (start_key) {
        rand_num = (421 * start_key + 1663) % 7875;
    } else
        rand_num = (421 * rand_num + 1663) % 7875;
    return rand_num;
}

void QSort(List<int> &array, int begin, int end){
    //base case
    if (begin >= end) return;

    int pivot = array.Ind(begin);
    int cnt=0;
    for(int i=begin+1;i<=end;i++){
        if(array.Ind(i)<=pivot) cnt++;
    }
    int pivInd = begin+cnt;
    array.Swap(begin, pivInd);
    int left = begin, right = end;
    while(left< pivInd && right > pivInd){
        while(array.Ind(left)<=pivot) left++;
        while(array.Ind(right)>pivot) right--;
        if(left< pivInd && right > pivInd) {
            array.Swap(left,right);
            left++;
            right--;
        }
    }

    QSort (array, begin, pivInd-1);
    QSort (array, pivInd+1, end);
}